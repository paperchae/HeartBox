import os
from utils.config import get_config
from tqdm import tqdm
import pandas as pd
import wfdb
import matplotlib.pyplot as plt
import numpy as np

from utils.wfdb_funcs import get_ecg_idx
from utils.pandas_utils import *

class ECG:
    def __init__(self, root_path: str):
        self.root_path = root_path
        # self.sub_group, self.patient_per_group, self.study_per_patient = self.get_directory_structure()
        self.machine_df = self.get_machine_measurement_info()
        self.note_df = self.waveform_note_links()
        self.df = pd.merge(self.machine_df, self.note_df, on=['subject_id', 'study_id'])

    def get_directory_structure(self):
        """
        Get directory structure of the root path.

        :param root_path: root path of the ECG waveform data
        :return: sub group of patients(e.g. [p1001, p1002, ...]
                 patient_by_group: dict of group: patient list
                 study_by_patient: dict of patient: study list
        """
        waveform_path = self.root_path + 'files/'
        sub_group = []
        patient_per_group = {}
        study_per_patient = {}
        for group in tqdm(sorted(os.listdir(waveform_path))):
            sub_group.append(os.path.join(waveform_path, group))
            patient_id = []
            for patient in os.listdir(os.path.join(waveform_path, group)):
                patient_id.append(patient)
                study_id = []
                if os.path.isdir(os.path.join(waveform_path, group, patient)):
                    for study in os.listdir(os.path.join(waveform_path, group, patient)):
                        study_id.append(study)
                else:
                    continue
                study_per_patient[patient] = study_id
            patient_per_group[group] = patient_id

        return sub_group, patient_per_group, study_per_patient

    def get_patient_over_n_study(self,
                                 study_per_patient,
                                 study_num: int):
        """
        Get patient list who has more than n studies.
        if study_num == 0, return all patients.

        :param study_per_patient: dict of patient: study list
        :param return_path: if True, return patient/study path
        :param study_num: number of studies
        :return: patient list
        """
        if study_num == 0:
            return list(study_per_patient.keys())
        else:
            patient_over_n_study = []
            for patient, studies in study_per_patient.items():
                if len(studies) >= study_num:
                    patient_over_n_study.append(int(patient[1:]))

                    test = ['/'.join([patient, study_id]) for study_id in studies]

            return patient_over_n_study

    def get_machine_measurement_info(self):
        """
        subject_id
            Description: "An identifier for the subject which aligns across the MIMIC-IV database"
            Example: "10000032"
        study_id
            Description: "An identifier for the study which the diagnostic ECG is associated with"
            Example: "40689238"
        cart_id
            Description: "An identifier specific to the ECG cart used to collect the diagnostic ECG waveform"
            Example: "6848296"
        ecg_time
            Description: "The date that the diagnostic ECG was collected on"
            Example: "2180-07-23 08:44:00"
        report_n
            Description: "A text based cardiology report generated by the ECG machine"
            Example: "Sinus rhythm, Possible right atrial abnormality"
        bandwidth
            Description: "The bandwidth of the ECG machine"
            Example: "0.005-150 Hz"
        filtering
            Description: "An indicator for the filter setting"
            Example: "60 Hz notch Baseline filter"
            Weird value: <not specified>
        rr_interval
            Description: "Time between successive R-waves (msec)"
            Example: "659"
        p_onset
            Description: "Time at the onset of the P-wave (msec)"
            Example: "40"
        p_end : 128  /
            Description: "Time at the end of the P-wave (msec)"
            Example: "128"
            Weird value e.g. 29999
        qrs_onset
            Description: "Time at the beginning of the QRS complex (msec)"
            Example: "170"
        qrs_end
            Description: "Time at the end of the QRS complex (msec)"
            Example: "258"
        t_end
            Description: "Time at the end of the T-wave (msec)"
            Example: "518"
        p_axis
            Description: "The electrical axis of the P-wave (degrees)"
            Example: "81"
        qrs_axis
            Description: "The electrical axis of the QRS complex (degrees)"
            Example: "77"
        t_axis
            Description: "The electrical axis of the T-wave (degrees)"
            Example: "79"

        :return:
        """
        machine_df = pd.read_csv(self.root_path + 'machine_measurements.csv', low_memory=False)
        return machine_df

    def waveform_note_links(self):
        """
        subject_id
            Description: "An identifier for the subject which aligns across the MIMIC-IV database"
            Example: "10000032"
        study_id
            Description: "An identifier for the study which the diagnostic ECG is associated with"
            Example: "40689238"
        waveform_path
            Description: "The path to the diagnostic ECG waveform"
            Example: "files/p1000/p10000032/s40689238/40689238"
        note_id
            Description: "An identifier for the note which the diagnostic ECG is associated with"
            Example: "10000032-EK-4"
        note_seq
            Description: "The sequence of the note which the diagnostic ECG is associated with"
            Example: "4"
        chart_time
            Description: "The date that the diagnostic ECG was collected on"
            Example: "2180-07-23 08:44:00"
        :return:
        """

        note_df = pd.read_csv(self.root_path + 'waveform_note_links.csv', low_memory=False)
        return note_df

class Clinical:
    def __init__(self, root_path):
        self.root_path = root_path

    def read_chartevent(self, subject_list, debug=False):
        """
        Read chartevent.csv.gz file and retrieve chartevent information of subject_list
        :param subject_list: list of target subject
        :return: chartevent_df
        """

        chunk_size = 10 ** 6
        cnt = 0
        gender_list = []
        age_list = []

        for chunk in pd.read_csv(self.root_path + 'chartevents.csv.gz', chunksize=chunk_size, compression='gzip',
                                 header=0, sep=',', low_memory=False):
            chunk = loc(chunk, 'SUBJECT_ID', 'in', subject_list)


class Patient:
    def __init__(self, subject_id):
        self.id = subject_id

    def get_subject_info(self, machine_df):
        """
        Read dataframe & get subject information.
        If there are many studies, return all studies.
        :return:
        """
        # study_id = study_per_patient[self.id]
        # study_df = machine_df.loc[machine_df['subject_id'] == self.id]
        subject_df = machine_df.loc[machine_df['subject_id'] == self.id]
        return subject_df

    def get_waveform_path(self, note_df):
        """
        get patient waveform_path according to self.id
        :param note_df:
        :return:
        """

        waveform_path = note_df.loc[note_df['subject_id'] == self.id]
        return waveform_path


# class Clinical:


if __name__ == '__main__':
    cfg = get_config('../config.yaml')
    root_path = cfg.preprocess.mimic.ecg_path
    ecg = ECG(root_path)
    groups, patients_per_group, studies_per_patient = ecg.get_directory_structure()
    measurement_df = ecg.get_machine_measurement_info()
    machine_df = ecg.machine_df

    target_patients = ecg.get_patient_over_n_study(studies_per_patient, study_num=3)
    for t in target_patients:
        id = t
        p = Patient(id)
        subject_df = p.get_subject_info(machine_df)
        waveform_df = p.get_waveform_path(ecg.note_df)
        # total_df 가 안찍히는 경우는 waveform_df 가 비어있는 경우
        total_df = pd.merge(subject_df, waveform_df, on=['subject_id', 'study_id'])
        # TODO: ecg_time 이랑 note_seq 랑 순서가 안맞음, ecg_time 을 clinical database 에서 anchor year 들고와야함
        # TODO: 날짜를 x축, total_df의 report_n 을 y축으로 그래프 그리기
        # TODO: ecg_time, charttime 같은거 같음 하나 삭제 or 서로 다른거 삭제?
        different_df = total_df[total_df['ecg_time'] == total_df['charttime']]
        sorted_by_note_seq = total_df.sort_values(by=['note_seq'])
        waveforms = sorted_by_note_seq['waveform_path'].tolist()
        for idx, study in sorted_by_note_seq.iterrows():
            reports = study.filter(regex='report_')
            nan_deleted_reports = reports.to_numpy()[~pd.isna(reports.tolist())]
            plt.title('study_id:{} \nreport: {}'.format(study['study_id'], str(nan_deleted_reports)))
            waveform_path = root_path + study['waveform_path']
            lead_i = np.squeeze(wfdb.rdrecord(waveform_path, channels=[0]).p_signal)
            plt.plot(lead_i)
            plt.show()
            print('test')

    print('test')

    print('test')
    print(len(target_patients))
